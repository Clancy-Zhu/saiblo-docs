# ADK User Guide-Lite

> 本Lite版指南旨在让选手在较短时间内创作出简单AI，更多ADK的详细使用方法请看进阶版指南。

## 0. 预备工作

请先前往Saiblo官网下载ADK包，确认内含`adk.py`、`sampleAI.py`以及`main.py`。

`adk.py`为你的AI提供的功能有：与Judger进行通讯，发送你的操作、读取对手的操作等；游戏状态维护，提供逻辑维护代码，能为你处理玩家的操作并提供当前局面信息。

`sampleAI.py`为一个已经实现的简易AI的代码，其中的框架可以沿用至你的AI程序中，或者你也可以直接在其上进行修改。

`main.py`用于运行你的AI程序。注意，如果你修改了`sampleAI.py`的文件名或新创建文件编写你的AI，请在`main.py`中同步修改。

## 1. 开始！

你需要做的是在`sampleAI.py`中实现你自己的策略，而当前其中已经有一个非常简单的策略实现了，即蛇沿着棋盘走“Z-字形”，不断前进并在到达地图边缘时转向遍历每一行。

为了简化编写AI的流程，你只需要修改`sampleAI.py`中的`judge`函数进行对当前蛇的操作，而其余部分代码会帮助你处理你当前的操作、对手的操作等其他流程。`judge`函数的参数可以自行修改，返回值应为一个长度为2，元素类型为`int`的列表（List），第一个元素代表你的操作类型，第二个元素代表你的操作参数，具体见下表：

| 操作类型 | 第一个元素 | 第二个元素                                                 |
| -------- | ---------- | ---------------------------------------------------------- |
| 移动     | 1          | 方向（0 : x轴正向，1 : y轴正向, 2 : x轴负向, 3 : y轴负向） |
| 使用道具 | 2          | 道具的编号                                                 |

当前judge函数有两个参数：`snake`以及`ctx`。`snake`代表当前操作对应的蛇，`ctx`则保存了当前局面的详细信息。你可以利用它们来优化你的决策过程。下一节中简要介绍了它们的部分使用方法。

## 2. 可供利用的信息

### 2.1 参数snake

`snake`代表当前需进行操作的蛇，其类型为自定义类`Snake`，在`adk.py`中实现。可供使用的成员属性及方法有：

- `coor_list: List[Tuple[int, int]]` 一个顺序（蛇头 -> 蛇尾）包含所有坐标的列表，列表中元素为包含两个`int`的元组，第一个为`x`坐标，第二个为`y`坐标。
- `item_list: List[Item]` 当前蛇所有的道具列表，列表中元素类型为自定义类`Item`，具体内容见后。
- `id: int` 蛇的编号。
- `length_bank: int` 长度银行中保存的长度。
- `camp: int` 蛇归属于玩家0/1。
- `get_len() -> int ` 返回当前蛇的长度
- `get_coor() -> List[Tuple[int, int]]`：返回当前蛇从头到尾坐标构成的列表

更多成员可见`adk.py`或进阶版指南，它们在编写AI时并不必要。

其中提到的`Item`道具类包含以下成员：

- `x: int` x坐标
- `y: int` y坐标
- `id: int` 道具编号
- `time: int` 道具生成的时间
- `type: int` 道具类型，`1`代表分裂道具，`2`代表融化射线。PS: 长度道具不会被保存，直接存入长度银行。
- `param: int` 道具参数，代表道具的有效时间。
- `gotten_time: int` 道具被蛇获取的时间（若道具仍在地图中未被蛇获取，为-1）。

### 2.2 参数ctx

`ctx`中保存了当前游戏的局面信息，类型为自定义类`Context`，在`adk.py`中实现。可供使用的成员属性及方法有：

- `snake_list: List[Snake]` 包含现存所有蛇，同一个玩家的蛇按照操作顺序排序。
- `game_map: Map` 现在的游戏地图，为自定义类`Map`，具体内容见后。
- `turn: int` 当前回合数
- `current_player: int` 当前玩家编号
- `get_map() -> Map` 返回当前地图
- `get_snake_count(camp: int) -> int` 返回当前`camp`选手蛇的数量
- `get_snake(id: int) -> Snake` 返回当前编号为id的蛇

更多成员可见`adk.py`或进阶版指南，它们在编写AI时并不必要。

其中提到的`Map`地图类包含以下成员：

- `wall_map: List[List[int]]` -1 / 0 / 1 代表无墙 / 0号选手的墙 / 1号选手的墙
- `snake_map: List[List[int]]` -1 / id 代表无 / id号蛇占据
- `item_map: List[List[int]]` -1 / id 代表无 / id号道具占据
- `item_list: List[Item]`现存所有道具的列表
- `length: int` 地图长度
- `width: int` 地图宽度
- `get_map_item(id: int) -> Item` 返回当前编号为id的道具

其中，各个地图二维数组的第一维代表`x`坐标，第二维代表`y`坐标，从`0`开始。

利用上述信息，相信智慧的你一定能够设计出一个和你一样智慧的AI！如果你想要更详细地了解AI程序处理的流程以及ADK的其他内容，请继续阅读进阶版指南。

### 附录：回放文件格式简介

Saiblo网站的对局支持下载回放文件，回放文件格式为json，包含以下几个字段：

- `game_config`字段，代表游戏的配置信息，包括地图长宽`length`/`width`、最大回合数`max_round`、随机数种子`random_seed`。
- `item_list`字段，代表游戏开始时生成的道具列表，其中道具的每个字段与上面的`Item`类中的成员一一对应。
- `round_info`字段，代表每回合开始时的信息，一回合的信息格式如下：

```json
{
  "gotten_item": [            // 此回合直接生成在蛇身上的道具。item和snake均为对应的id
    {"item": 0, "snake": 1},
    {"item": 2, "snake": 3}
  ],
  "expired_item": [           // 此回合过期的道具，若为地图道具则snake为-1。
    {"item": 1, "snake": 2},
    {"item": 3, "snake": 5}
  ],
  "invalid_item": [],         // 此回合应无效化道具，弃用字段。
  "extra_length": [           // 此回合开始时因为某种原因（直接刷新的长度道具）而让长度银行发生变化的信息，el代表新的长度银行值
    {"snake": 1, "el": 5}
  ]
}
```

- `operations`字段，代表每个回合的操作以及其附加信息，一回合的信息格式如下：

```json
{
  // 原操作，type代表类型，snake代表蛇编号，direction代表方向，item_id代表道具编号。
  "basic": { "type": 1, "snake": 0, "direction": 0, "item_id": -1 },
  
  // 以下为移动操作所需要的附加信息
  "dead_snake": [1,2,3], // 因为本操作而消失的蛇的id列表。
  "should_solid": true,  // 执行本操作的蛇是否固化。
  "extra_solid_area": [  // 执行本操作的蛇固化的区域，按x、y升序排序。
      { "x": 2, "y": 1 },
      { "x": 2, "y": 2 },
      { "x": 3, "y": 1 },
      { "x": 3, "y": 2 },
  ],
  "got_item": 4,         // 执行本操作的蛇操作后吃到的道具。-1表示不存在。
  "extra_length": 1,     // “长度银行”剩余长度。
  
  // 以下为分裂道具所需要的附加信息
  "new_snake_id": 12     // 分裂产生的新蛇的id，没有则为-1。
}
```

- `end_info`字段，代表结束信息。`type`为结束类型，`winner`代表获胜玩家编号，`score`代表两个玩家的得分，第一个值为`0`号玩家得分，第二个值为`1`号玩家得分，`err`代表错误信息。